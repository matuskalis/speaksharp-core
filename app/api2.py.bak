"""
FastAPI application for SpeakSharp Core.

Provides HTTP endpoints for:
- Text-based tutoring
- Voice-based tutoring
- SRS card management
- User profiles
- Session management
"""

import uuid
from typing import Optional, List, Dict, Any
from datetime import datetime
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException, Depends, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field
import json
import base64

from app.db import Database, get_db
from app.tutor_agent import TutorAgent
from app.voice_session import VoiceSession
from app.config import load_config
from app.models import TutorResponse
from app.auth import verify_token, get_or_create_user


# Pydantic Models for API

class TutorTextRequest(BaseModel):
    """Request model for text-based tutoring."""
    user_id: uuid.UUID
    text: str
    scenario_id: Optional[str] = None
    context: Optional[str] = None
    session_id: Optional[uuid.UUID] = None


class TutorTextResponse(BaseModel):
    """Response model for text-based tutoring."""
    message: str
    errors: List[Dict[str, Any]] = Field(default_factory=list)
    micro_task: Optional[str] = None
    session_id: uuid.UUID


class TutorVoiceRequest(BaseModel):
    """Request model for voice-based tutoring."""
    user_id: uuid.UUID
    audio_path: Optional[str] = None  # Path to audio file or URL
    audio_bytes: Optional[str] = None  # Base64 encoded audio (future)
    session_id: Optional[uuid.UUID] = None


class TutorVoiceResponse(BaseModel):
    """Response model for voice-based tutoring."""
    transcript: str
    message: str
    errors: List[Dict[str, Any]] = Field(default_factory=list)
    audio_url: Optional[str] = None  # URL to response audio
    session_id: uuid.UUID


class SRSDueResponse(BaseModel):
    """Response model for due SRS cards."""
    cards: List[Dict[str, Any]]
    count: int


class SRSReviewRequest(BaseModel):
    """Request model for SRS card review."""
    card_id: uuid.UUID
    quality: int = Field(..., ge=0, le=5)
    response_time_ms: Optional[int] = None
    user_response: Optional[str] = None
    correct: bool = True


class UserProfileResponse(BaseModel):
    """Response model for user profile."""
    user_id: uuid.UUID
    level: str
    native_language: Optional[str] = None
    goals: Optional[List[str]] = None
    interests: Optional[List[str]] = None
    daily_time_goal: Optional[int] = None
    onboarding_completed: bool = False
    full_name: Optional[str] = None
    trial_start_date: Optional[datetime] = None
    trial_end_date: Optional[datetime] = None
    subscription_status: Optional[str] = None
    subscription_tier: Optional[str] = None
    is_tester: bool = False
    created_at: datetime
    updated_at: datetime


class CreateUserRequest(BaseModel):
    """Request model for creating a user."""
    user_id: Optional[uuid.UUID] = None
    level: str = "A1"
    native_language: Optional[str] = None
    goals: Optional[List[str]] = None
    interests: Optional[List[str]] = None


class UpdateProfileRequest(BaseModel):
    """Request model for updating user profile."""
    level: Optional[str] = None
    native_language: Optional[str] = None


class VoicePreferences(BaseModel):
    """Voice preferences model."""
    voice: str = "alloy"
    speech_speed: float = 1.0
    auto_play_responses: bool = True
    show_transcription: bool = True
    microphone_sensitivity: float = 0.5


class UpdateVoicePreferencesRequest(BaseModel):
    """Request model for updating voice preferences."""
    voice: Optional[str] = None
    speech_speed: Optional[float] = None
    auto_play_responses: Optional[bool] = None
    show_transcription: Optional[bool] = None
    microphone_sensitivity: Optional[float] = None


class HealthResponse(BaseModel):
    """Response model for health check."""
    status: str
    database: str
    timestamp: datetime


# Application lifecycle


def run_migrations(db):
    """Run database migrations on startup."""
    try:
        with db.get_connection() as conn:
            with conn.cursor() as cur:
                # Migration 006: Add onboarding_completed and full_name
                cur.execute("""
                    ALTER TABLE user_profiles
                    ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE;
                """)
                cur.execute("""
                    ALTER TABLE user_profiles
                    ADD COLUMN IF NOT EXISTS full_name VARCHAR(255);
                """)
                # Set existing users as having completed onboarding
                cur.execute("""
                    UPDATE user_profiles
                    SET onboarding_completed = TRUE
                    WHERE onboarding_completed IS NULL OR onboarding_completed = FALSE;
                """)

                # Migration 007: Add voice preferences
                cur.execute("""
                    ALTER TABLE user_profiles
                    ADD COLUMN IF NOT EXISTS voice_preferences JSONB DEFAULT '{"voice": "alloy", "speech_speed": 1.0, "auto_play_responses": true, "show_transcription": true, "microphone_sensitivity": 0.5}'::jsonb;
                """)

                conn.commit()
                print("âœ“ Database migrations applied")
    except Exception as e:
        print(f"âš ï¸  Migration error (may already exist): {e}")


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager."""
    # Startup
    print("ðŸš€ Starting SpeakSharp API...")
    db = get_db()
    if db.health_check():
        print("âœ“ Database connection successful")
        run_migrations(db)
    else:
        print("âš ï¸  Database connection failed - some features may not work")

    yield

    # Shutdown
    print("ðŸ‘‹ Shutting down SpeakSharp API...")


# FastAPI app initialization

app = FastAPI(
    title="SpeakSharp Core API",
    description="AI-powered English learning tutor API",
    version="1.0.0",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Dependency injection


def get_database() -> Database:
    """Get database instance."""
    return get_db()


# API Endpoints


@app.get("/", tags=["General"])
async def root():
    """Root endpoint."""
    return {
        "service": "SpeakSharp Core API",
        "version": "1.0.0",
        "status": "running"
    }


@app.get("/health", response_model=HealthResponse, tags=["General"])
async def health_check(db: Database = Depends(get_database)):
    """
    Health check endpoint.

    Returns service status and database connectivity.
    """
    db_status = "healthy" if db.health_check() else "unhealthy"

    return HealthResponse(
        status="healthy" if db_status == "healthy" else "degraded",
        database=db_status,
        timestamp=datetime.now()
    )


# User Profile Endpoints


@app.post("/api/users", response_model=UserProfileResponse, tags=["Users"])
async def create_user(
    request: CreateUserRequest,
    db: Database = Depends(get_database)
):
    """
    Create a new user profile.

    Args:
        request: User creation request

    Returns:
        Created user profile
    """
    try:
        user_id = request.user_id or uuid.uuid4()

        user = db.create_user(
            user_id=user_id,
            level=request.level,
            native_language=request.native_language,
            goals=request.goals,
            interests=request.interests
        )

        return UserProfileResponse(**user)

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create user: {str(e)}")


@app.get("/api/users/me", response_model=UserProfileResponse, tags=["Users"])
async def get_current_user(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get current user's profile from JWT token.

    Requires JWT authentication. User ID is extracted from the token.
    User profile is auto-created on first request if it doesn't exist.

    Returns:
        User profile
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    # Auto-create user profile if doesn't exist
    user = get_or_create_user(str(user_id))

    return UserProfileResponse(**user)


@app.get("/api/users/{user_id}", response_model=UserProfileResponse, tags=["Users"])
async def get_user(
    user_id: uuid.UUID,
    db: Database = Depends(get_database)
):
    """
    Get user profile by ID.

    Args:
        user_id: User UUID

    Returns:
        User profile
    """
    user = db.get_user(user_id)

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return UserProfileResponse(**user)


@app.put("/api/users/me/profile", response_model=UserProfileResponse, tags=["Users"])
async def update_current_user_profile(
    request: UpdateProfileRequest,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Update current user's profile (level and/or native_language).

    Requires JWT authentication. User ID is extracted from the token.

    Args:
        request: Profile update request with optional level and native_language

    Returns:
        Updated user profile
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    # Auto-create user profile if doesn't exist
    get_or_create_user(str(user_id))

    # Update profile
    try:
        success = db.update_user_profile(
            user_id=user_id,
            level=request.level,
            native_language=request.native_language
        )

        if not success:
            raise HTTPException(status_code=404, detail="User not found")

        # Fetch updated profile
        user = db.get_user(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found after update")

        return UserProfileResponse(**user)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update profile: {str(e)}")


# Tutor Endpoints


from fastapi import Body

def build_rich_tutor_context(
    db: Database,
    user_id: uuid.UUID,
    user: dict,
    scenario_id: Optional[str] = None,
    session_id: Optional[uuid.UUID] = None,
    context_str: Optional[str] = None,
    turn_number: int = 1,
) -> dict:
    """
    Build rich context for the AI tutor including user profile, errors, and skills.

    This context helps the AI personalize feedback based on:
    - User's level, goals, interests, native language
    - Recent error patterns (to address recurring mistakes)
    - Weak skills (to focus corrections)
    """
    # Base context
    context = {
        "source": "api",
        "mode": "scenario" if scenario_id else "text",
        "scenario_id": scenario_id,
        "session_id": str(session_id) if session_id else None,
        "user_id": str(user_id),
        "turn_number": turn_number,
        "raw_context": context_str,
    }

    # User profile data
    context["level"] = user.get('level', 'A1')
    context["native_language"] = user.get('native_language')
    context["goals"] = user.get('goals', [])
    context["interests"] = user.get('interests', [])

    # Recent errors (last 10) - helps identify recurring patterns
    try:
        recent_errors = db.get_user_errors(user_id, limit=10)
        if recent_errors:
            # Summarize error patterns
            error_summary = []
            error_types = {}
            for err in recent_errors:
                err_type = err.get('error_type', 'unknown')
                error_types[err_type] = error_types.get(err_type, 0) + 1
                if len(error_summary) < 5:  # Keep top 5 examples
                    error_summary.append({
                        "type": err_type,
                        "mistake": err.get('user_sentence', '')[:100],
                        "correction": err.get('corrected_sentence', '')[:100],
                    })
            context["recent_error_patterns"] = error_types
            context["recent_error_examples"] = error_summary
    except Exception:
        pass  # Don't fail if error history unavailable

    # Weak skills (top 3) - focus corrections on problem areas
    try:
        weak_skills = db.get_weakest_skills(user_id, limit=3)
        if weak_skills:
            context["weak_skills"] = [
                {"skill": s.get('skill_key'), "mastery": s.get('mastery_score', 0)}
                for s in weak_skills
            ]
    except Exception:
        pass  # Don't fail if skill data unavailable

    return context


@app.post("/api/tutor/text", tags=["Tutor"])
async def tutor_text(
    payload: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Process text input through the tutor agent.

    Requires JWT authentication. User ID is extracted from the token.
    User profile is auto-created on first request if it doesn't exist.
    """
    try:
        # Convert user_id from token to UUID
        try:
            user_id = uuid.UUID(user_id_from_token)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid user_id from token")

        # Auto-create user profile if doesn't exist
        user = get_or_create_user(str(user_id))

        # Extract text from payload
        text = payload.get("text")
        if not isinstance(text, str) or not text.strip():
            raise HTTPException(status_code=400, detail="Invalid or missing text")

        scenario_id = payload.get("scenario_id")
        context_str = payload.get("context")
        turn_number = payload.get("turn_number", 1)
        session_id_raw = payload.get("session_id")
        session_id: Optional[uuid.UUID] = None
        if session_id_raw:
            try:
                session_id = uuid.UUID(str(session_id_raw))
            except Exception:
                raise HTTPException(status_code=400, detail="Invalid session_id")

        # Create DB session if none provided
        if session_id is None:
            session = db.create_session(
                user_id=user_id,
                session_type="scenario" if scenario_id else "free_chat",
                metadata={
                    "source": "api",
                    "mode": "text",
                    "scenario_id": scenario_id,
                    "context": context_str,
                },
            )
            session_id = session["session_id"]
        else:
            session = {"session_id": session_id}

        # Build rich context with user profile, errors, and skills
        rich_context = build_rich_tutor_context(
            db=db,
            user_id=user_id,
            user=user,
            scenario_id=scenario_id,
            session_id=session_id,
            context_str=context_str,
            turn_number=turn_number,
        )

        # Run tutor with enriched context and conversation memory
        tutor = TutorAgent(user_id=str(user_id), db=db)
        tutor_response: TutorResponse = tutor.process_user_input(
            text,
            context=rich_context,
        )

        # Log errors + create SRS cards
        for err in tutor_response.errors:
            err_record = db.log_error(
                user_id=user_id,
                error_type=err.type.value,
                user_sentence=err.user_sentence,
                corrected_sentence=err.corrected_sentence,
                explanation=err.explanation,
                session_id=session_id,
                source_type="text_tutor",
            )
            db.create_card_from_error(error_id=err_record["error_id"])

        # Save conversation turn to memory
        try:
            db.save_conversation_turn(
                user_id=user_id,
                session_id=session_id,
                turn_number=turn_number,
                user_message=text,
                tutor_response=tutor_response.message,
                context_type=scenario_id or "free_chat",
                context_id=scenario_id,
                metadata={
                    "error_count": len(tutor_response.errors),
                    "has_micro_task": tutor_response.micro_task is not None
                }
            )
        except Exception as e:
            print(f"Warning: Failed to save conversation turn: {e}")

        # Build response
        return {
            "message": tutor_response.message,
            "errors": [e.model_dump() for e in tutor_response.errors],
            "micro_task": tutor_response.micro_task,
            "session_id": str(session_id),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Tutor text error: {e}")

@app.post("/api/tutor/voice", tags=["Tutor"])
async def tutor_voice(
    file: UploadFile,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Process voice input through ASR + Tutor + TTS.

    Requires JWT authentication. User ID is extracted from the token.

    Accepts multipart/form-data with audio file.

    Pipeline:
    1. ASR: Transcribe audio to text (OpenAI Whisper)
    2. Tutor: Process text through TutorAgent
    3. TTS: Synthesize tutor response (OpenAI TTS)
    4. Log errors and create SRS cards

    Returns:
        JSON with transcript, tutor response, and base64 audio
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    # Auto-create user profile if doesn't exist
    user = get_or_create_user(str(user_id))
    user_level = user.get('level', 'A1')

    # Create DB session
    session = db.create_session(
        user_id=user_id,
        session_type="voice_tutor",
        metadata={"source": "api", "mode": "voice"}
    )
    session_id = session["session_id"]

    try:
        # Read audio bytes from uploaded file
        audio_bytes = await file.read()
        filename = file.filename or "audio.webm"

        # Create voice session
        from app.voice_session import VoiceSession
        voice_session = VoiceSession(
            user_level=user_level,
            mode="free_chat",
            context={"session_id": str(session_id), "user_id": str(user_id), "filename": filename}
        )

        # Process audio bytes through voice pipeline
        result = voice_session.handle_audio_input(
            audio_input=audio_bytes,
            generate_audio_response=True
        )

        # Log errors and create SRS cards
        for err in result.tutor_response.errors:
            err_record = db.log_error(
                user_id=user_id,
                error_type=err.type.value,
                user_sentence=err.user_sentence,
                corrected_sentence=err.corrected_sentence,
                explanation=err.explanation,
                session_id=session_id,
                source_type="voice_tutor",
            )
            db.create_card_from_error(error_id=err_record["error_id"])

        # Save conversation turn to memory
        try:
            db.save_conversation_turn(
                user_id=user_id,
                session_id=session_id,
                turn_number=1,  # Voice sessions are typically one turn at a time
                user_message=result.recognized_text,
                tutor_response=result.tutor_response.message,
                context_type="voice_tutor",
                context_id=None,
                metadata={
                    "error_count": len(result.tutor_response.errors),
                    "has_audio": True,
                    "filename": filename
                }
            )
        except Exception as e:
            print(f"Warning: Failed to save voice conversation turn: {e}")

        # Read TTS audio file and encode as base64
        import base64
        audio_base64 = None
        if result.tts_output_path:
            try:
                with open(result.tts_output_path, 'rb') as audio_file:
                    audio_base64 = base64.b64encode(audio_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Warning: Failed to read TTS audio: {e}")

        # Return response
        return {
            "transcript": result.recognized_text,
            "tutor_response": {
                "message": result.tutor_response.message,
                "errors": [e.model_dump() for e in result.tutor_response.errors],
                "micro_task": result.tutor_response.micro_task,
            },
            "audio_base64": audio_base64,
            "session_id": str(session_id),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Voice tutor error: {str(e)}")


@app.post("/api/tutor/voice/stream", tags=["Tutor"])
async def tutor_voice_streaming(
    file: UploadFile,
    mode: Optional[str] = "chunk",  # "chunk" or "sentence"
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Process voice input with streaming TTS response (SSE format).

    Requires JWT authentication. User ID is extracted from the token.

    Accepts multipart/form-data with audio file.

    Query params:
    - mode: "chunk" (default) for continuous streaming, "sentence" for sentence-by-sentence

    Pipeline:
    1. ASR: Transcribe audio to text (OpenAI Whisper)
    2. Tutor: Process text through TutorAgent
    3. TTS: Stream audio response in chunks

    Returns:
        Server-Sent Events (SSE) stream with the following event types:
        - transcript: User's transcribed speech
        - tutor_response: Tutor's text response with errors
        - audio_start: Signal that audio streaming is beginning
        - audio_chunk: Base64-encoded audio data chunks
        - audio_end: Signal that audio streaming is complete
        - sentence_start/end: (sentence mode only) Sentence boundaries
        - complete: Final event with metadata

    Benefits:
    - Lower perceived latency (audio starts playing sooner)
    - Progressive feedback to user
    - Better UX with incremental updates
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    # Auto-create user profile if doesn't exist
    user = get_or_create_user(str(user_id))
    user_level = user.get('level', 'A1')

    # Create DB session
    session = db.create_session(
        user_id=user_id,
        session_type="voice_tutor_streaming",
        metadata={"source": "api", "mode": "voice", "streaming": True}
    )
    session_id = session["session_id"]

    async def event_generator():
        """Generate SSE events for streaming response."""
        try:
            # Read audio bytes from uploaded file
            audio_bytes = await file.read()
            filename = file.filename or "audio.webm"

            # Create voice session
            from app.voice_session import VoiceSession
            voice_session = VoiceSession(
                user_level=user_level,
                mode="free_chat",
                context={"session_id": str(session_id), "user_id": str(user_id), "filename": filename}
            )

            # Choose streaming mode
            if mode == "sentence":
                stream_func = voice_session.handle_audio_input_streaming_sentences
            else:
                stream_func = voice_session.handle_audio_input_streaming

            # Track tutor response for error logging
            tutor_response_data = None

            # Stream events
            for event in stream_func(audio_bytes):
                event_type = event["type"]
                event_data = event["data"]

                # Store tutor response for later error logging
                if event_type == "tutor_response":
                    tutor_response_data = event_data

                # For audio chunks, encode as base64
                if event_type == "audio_chunk":
                    chunk = event_data["chunk"]
                    event_data = {
                        "chunk": base64.b64encode(chunk).decode('utf-8')
                    }

                # Format as SSE
                yield f"event: {event_type}\n"
                yield f"data: {json.dumps(event_data)}\n\n"

            # Log errors after streaming completes
            if tutor_response_data and tutor_response_data.get("errors"):
                for err in tutor_response_data["errors"]:
                    try:
                        err_record = db.log_error(
                            user_id=user_id,
                            error_type=err["type"],
                            user_sentence=err["user_sentence"],
                            corrected_sentence=err["corrected_sentence"],
                            explanation=err["explanation"],
                            session_id=session_id,
                            source_type="voice_tutor_streaming",
                        )
                        db.create_card_from_error(error_id=err_record["error_id"])
                    except Exception as e:
                        print(f"Warning: Failed to log error: {e}")

        except Exception as e:
            # Send error event
            error_data = {"error": str(e)}
            yield f"event: error\n"
            yield f"data: {json.dumps(error_data)}\n\n"

    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",  # Disable nginx buffering
        }
    )


# SRS Endpoints


@app.get("/api/srs/due", response_model=SRSDueResponse, tags=["SRS"])
async def get_due_cards(
    limit: int = 20,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get due SRS cards for review.

    Requires JWT authentication. User ID is extracted from the token.

    Args:
        limit: Maximum number of cards to return

    Returns:
        List of due cards
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    # Auto-create user profile if doesn't exist
    get_or_create_user(str(user_id))

    try:
        cards = db.get_due_cards(user_id, limit=limit)

        return SRSDueResponse(
            cards=cards,
            count=len(cards)
        )

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get due cards: {str(e)}"
        )


@app.post("/api/srs/review", tags=["SRS"])
async def review_card(
    request: SRSReviewRequest,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit a review for an SRS card.

    Requires JWT authentication. User ID is extracted from the token.
    This updates the card using the SM-2 algorithm and logs the review.

    Args:
        request: SRS review request

    Returns:
        Success confirmation
    """
    # Auto-create user profile if doesn't exist
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    get_or_create_user(str(user_id))

    # Verify card exists
    card = db.get_card(request.card_id)
    if not card:
        raise HTTPException(status_code=404, detail="Card not found")

    try:
        db.update_card_after_review(
            card_id=request.card_id,
            quality=request.quality,
            response_time_ms=request.response_time_ms,
            user_response=request.user_response,
            correct=request.correct
        )

        return {
            "status": "success",
            "message": "Review recorded successfully",
            "card_id": request.card_id
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to record review: {str(e)}"
        )


@app.post("/api/srs/from-error/{error_id}", tags=["SRS"])
async def create_card_from_error(
    error_id: uuid.UUID,
    db: Database = Depends(get_database)
):
    """
    Create an SRS card from a logged error.

    Args:
        error_id: Error log UUID

    Returns:
        Created card ID
    """
    try:
        card_id = db.create_card_from_error(error_id)

        return {
            "status": "success",
            "message": "Card created from error",
            "card_id": card_id,
            "error_id": error_id
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to create card from error: {str(e)}"
        )


# Error Log Endpoints


@app.get("/api/errors/{user_id}", tags=["Errors"])
async def get_user_errors(
    user_id: uuid.UUID,
    limit: int = 50,
    unrecycled_only: bool = False,
    db: Database = Depends(get_database)
):
    """
    Get user's error history.

    Args:
        user_id: User UUID
        limit: Maximum number of errors to return
        unrecycled_only: Only return errors not yet converted to SRS cards

    Returns:
        List of errors
    """
    # Verify user exists
    user = db.get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    try:
        errors = db.get_user_errors(
            user_id=user_id,
            limit=limit,
            unrecycled_only=unrecycled_only
        )

        return {
            "errors": errors,
            "count": len(errors)
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get errors: {str(e)}"
        )


# Skill Graph Endpoints


@app.get("/api/skills/weakest", tags=["Skills"])
async def get_weakest_skills(
    limit: int = 3,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get user's weakest skills (authenticated).

    Returns top 3 weakest skills by default with error counts.
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        skills = db.get_weakest_skills(user_id, limit=limit)

        return {
            "skills": skills,
            "count": len(skills)
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get weakest skills: {str(e)}"
        )


# ============================================================================
# Stats & Analytics Endpoints
# ============================================================================

@app.get("/api/stats/errors", tags=["Stats"])
async def get_error_stats(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get error statistics for the authenticated user.

    Returns:
    - total_errors: Total number of errors logged
    - errors_by_type: Breakdown by error type (grammar, vocab, fluency, structure)
    - last_errors: Last 10 errors with details
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        with db.get_connection() as conn:
            with conn.cursor() as cursor:
                # Total errors
                cursor.execute("""
                    SELECT COUNT(*) as total FROM error_log WHERE user_id = %s
                """, (str(user_id),))
                result = cursor.fetchone()
                total_errors = result['total'] if result else 0

                # Errors by type
                cursor.execute("""
                    SELECT error_type, COUNT(*) as count
                    FROM error_log
                    WHERE user_id = %s
                    GROUP BY error_type
                    ORDER BY count DESC
                """, (str(user_id),))
                errors_by_type = {row['error_type']: row['count'] for row in cursor.fetchall()}

                # Last 10 errors
                cursor.execute("""
                    SELECT
                        user_sentence,
                        corrected_sentence,
                        error_type,
                        explanation,
                        occurred_at
                    FROM error_log
                    WHERE user_id = %s
                    ORDER BY occurred_at DESC
                    LIMIT 10
                """, (str(user_id),))

                last_errors = [
                    {
                        "before_text": row['user_sentence'],
                        "after_text": row['corrected_sentence'],
                        "type": row['error_type'],
                        "explanation": row['explanation'],
                        "timestamp": row['occurred_at'].isoformat() if row['occurred_at'] else None
                    }
                    for row in cursor.fetchall()
                ]

                return {
                    "total_errors": total_errors,
                    "errors_by_type": errors_by_type,
                    "last_errors": last_errors
                }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get error stats: {str(e)}"
        )


@app.get("/api/stats/srs", tags=["Stats"])
async def get_srs_stats(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get SRS statistics for the authenticated user.

    Returns:
    - total_cards: Total number of SRS cards
    - due_today: Number of cards due for review today
    - reviewed_today: Number of cards reviewed today
    - success_rate_today: Success rate for today's reviews (0-100)
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        with db.get_connection() as conn:
            with conn.cursor() as cursor:
                # Total cards
                cursor.execute("""
                    SELECT COUNT(*) as total FROM srs_cards WHERE user_id = %s
                """, (str(user_id),))
                result = cursor.fetchone()
                total_cards = result['total'] if result else 0

                # Due today
                cursor.execute("""
                    SELECT COUNT(*) as total
                    FROM srs_cards
                    WHERE user_id = %s AND next_review_date <= NOW()
                """, (str(user_id),))
                result = cursor.fetchone()
                due_today = result['total'] if result else 0

                # Reviewed today
                cursor.execute("""
                    SELECT COUNT(*) as total
                    FROM srs_reviews
                    WHERE user_id = %s AND DATE(reviewed_at) = CURRENT_DATE
                """, (str(user_id),))
                result = cursor.fetchone()
                reviewed_today = result['total'] if result else 0

                # Success rate today (quality >= 3 is considered success)
                cursor.execute("""
                    SELECT
                        COUNT(*) FILTER (WHERE quality >= 3) as successes,
                        COUNT(*) as total
                    FROM srs_reviews
                    WHERE user_id = %s AND DATE(reviewed_at) = CURRENT_DATE
                """, (str(user_id),))

                result = cursor.fetchone()
                successes = result['successes'] if result and result['successes'] else 0
                total_reviews = result['total'] if result and result['total'] else 0
                success_rate_today = (successes / total_reviews * 100) if total_reviews > 0 else 0

                return {
                    "total_cards": total_cards,
                    "due_today": due_today,
                    "reviewed_today": reviewed_today,
                    "success_rate_today": round(success_rate_today, 1)
                }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get SRS stats: {str(e)}"
        )


# ============================================================================
# Lessons Endpoints
# ============================================================================

@app.get("/api/lessons", tags=["Lessons"])
async def get_lessons(
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get all available lessons.

    Returns a list of all lessons with their metadata.
    """
    from app.lessons import LESSON_LIBRARY

    lessons_list = [
        {
            "lesson_id": lesson.lesson_id,
            "title": lesson.title,
            "level": lesson.level,
            "skill_targets": lesson.skill_targets,
            "duration_minutes": lesson.duration_minutes,
        }
        for lesson in LESSON_LIBRARY.values()
    ]

    return {"lessons": lessons_list, "count": len(lessons_list)}


@app.get("/api/lessons/{lesson_id}", tags=["Lessons"])
async def get_lesson(
    lesson_id: str,
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get a specific lesson by ID.

    Returns the full lesson including explanation, examples, and practice tasks.
    """
    from app.lessons import LESSON_LIBRARY

    if lesson_id not in LESSON_LIBRARY:
        raise HTTPException(status_code=404, detail=f"Lesson '{lesson_id}' not found")

    lesson = LESSON_LIBRARY[lesson_id]

    return {
        "lesson_id": lesson.lesson_id,
        "title": lesson.title,
        "level": lesson.level,
        "skill_targets": lesson.skill_targets,
        "duration_minutes": lesson.duration_minutes,
        "context": lesson.context,
        "target_language": lesson.target_language,
        "explanation": lesson.explanation,
        "examples": lesson.examples,
        "controlled_practice": [
            {
                "task_type": task.task_type,
                "prompt": task.prompt,
                "example_answer": task.example_answer,
            }
            for task in lesson.controlled_practice
        ],
        "freer_production": {
            "task_type": lesson.freer_production.task_type,
            "prompt": lesson.freer_production.prompt,
            "example_answer": lesson.freer_production.example_answer,
        },
        "summary": lesson.summary,
    }


@app.post("/api/lessons/{lesson_id}/submit", tags=["Lessons"])
async def submit_lesson_task(
    lesson_id: str,
    payload: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit a lesson task answer and get AI feedback.

    Payload:
    {
        "task_index": 0,  # Index of the task (0 for first controlled practice, -1 for freer production)
        "user_answer": "I eat breakfast at 8 AM."
    }

    Returns tutor feedback on the answer.
    """
    from app.lessons import LESSON_LIBRARY
    from app.tutor_agent import TutorAgent

    if lesson_id not in LESSON_LIBRARY:
        raise HTTPException(status_code=404, detail=f"Lesson '{lesson_id}' not found")

    user_answer = payload.get("user_answer")
    task_index = payload.get("task_index")

    if not isinstance(user_answer, str) or not user_answer.strip():
        raise HTTPException(status_code=400, detail="Invalid or missing user_answer")

    if task_index is None:
        raise HTTPException(status_code=400, detail="Missing task_index")

    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    lesson = LESSON_LIBRARY[lesson_id]

    # Get the task
    if task_index == -1:
        task = lesson.freer_production
    elif 0 <= task_index < len(lesson.controlled_practice):
        task = lesson.controlled_practice[task_index]
    else:
        raise HTTPException(status_code=400, detail=f"Invalid task_index {task_index}")

    # Create DB session
    session = db.create_session(
        user_id=user_id,
        session_type="lesson",
        metadata={"lesson_id": lesson_id, "task_index": task_index}
    )
    session_id = session["session_id"]

    # Process through tutor
    tutor = TutorAgent()
    user = get_or_create_user(str(user_id))
    user_level = user.get('level', 'A1')

    context_str = f"Lesson: {lesson.title}. Task: {task.prompt}"
    if task.expected_pattern:
        context_str += f" Expected pattern: {task.expected_pattern}"

    tutor_response = tutor.process_user_input(
        user_answer,
        context={
            "mode": "lesson",
            "level": user_level,
            "lesson_id": lesson_id,
            "task_index": task_index,
            "context": context_str,
        }
    )

    # Log errors and create SRS cards
    for err in tutor_response.errors:
        err_record = db.log_error(
            user_id=user_id,
            error_type=err.type.value,
            user_sentence=err.user_sentence,
            corrected_sentence=err.corrected_sentence,
            explanation=err.explanation,
            session_id=session_id,
            source_type="lesson",
        )
        db.create_card_from_error(error_id=err_record["error_id"])

    return {
        "message": tutor_response.message,
        "errors": [
            {
                "type": err.type.value,
                "user_sentence": err.user_sentence,
                "corrected_sentence": err.corrected_sentence,
                "explanation": err.explanation,
            }
            for err in tutor_response.errors
        ],
        "micro_task": tutor_response.micro_task,
        "session_id": str(session_id),
    }


# ============================================================================
# Scenarios Endpoints
# ============================================================================

@app.get("/api/scenarios", tags=["Scenarios"])
async def get_scenarios(
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get all available scenarios.

    Returns a list of all scenarios with their metadata.
    """
    from app.scenarios import SCENARIO_TEMPLATES

    scenarios_list = [
        {
            "scenario_id": scenario.scenario_id,
            "title": scenario.title,
            "level_min": scenario.level_min,
            "level_max": scenario.level_max,
            "situation_description": scenario.situation_description,
            "difficulty_tags": scenario.difficulty_tags,
        }
        for scenario in SCENARIO_TEMPLATES.values()
    ]

    return {"scenarios": scenarios_list, "count": len(scenarios_list)}


@app.get("/api/scenarios/{scenario_id}", tags=["Scenarios"])
async def get_scenario(
    scenario_id: str,
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get a specific scenario by ID.

    Returns the full scenario including situation, goal, task, and success criteria.
    """
    from app.scenarios import SCENARIO_TEMPLATES

    if scenario_id not in SCENARIO_TEMPLATES:
        raise HTTPException(status_code=404, detail=f"Scenario '{scenario_id}' not found")

    scenario = SCENARIO_TEMPLATES[scenario_id]

    return {
        "scenario_id": scenario.scenario_id,
        "title": scenario.title,
        "level_min": scenario.level_min,
        "level_max": scenario.level_max,
        "situation_description": scenario.situation_description,
        "user_goal": scenario.user_goal,
        "task": scenario.task,
        "success_criteria": scenario.success_criteria,
        "difficulty_tags": scenario.difficulty_tags,
        "user_variables": scenario.user_variables,
    }


@app.post("/api/scenarios/{scenario_id}/respond", tags=["Scenarios"])
async def submit_scenario_response(
    scenario_id: str,
    payload: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit a response in a scenario conversation.

    Payload:
    {
        "user_input": "I'd like a coffee, please.",
        "turn_number": 1
    }

    Returns AI response and feedback.
    """
    from app.scenarios import SCENARIO_TEMPLATES
    from app.tutor_agent import TutorAgent

    if scenario_id not in SCENARIO_TEMPLATES:
        raise HTTPException(status_code=404, detail=f"Scenario '{scenario_id}' not found")

    user_input = payload.get("user_input")
    turn_number = payload.get("turn_number", 1)

    if not isinstance(user_input, str) or not user_input.strip():
        raise HTTPException(status_code=400, detail="Invalid or missing user_input")

    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    scenario = SCENARIO_TEMPLATES[scenario_id]

    # Create or get session
    session = db.create_session(
        user_id=user_id,
        session_type="scenario",
        metadata={"scenario_id": scenario_id, "turn_number": turn_number}
    )
    session_id = session["session_id"]

    # Process through tutor
    tutor = TutorAgent()
    user = get_or_create_user(str(user_id))
    user_level = user.get('level', 'A1')

    context_str = f"Scenario: {scenario.title}. {scenario.situation_description} Your task: {scenario.task}"

    tutor_response = tutor.process_user_input(
        user_input,
        context={
            "mode": "scenario",
            "level": user_level,
            "scenario_id": scenario_id,
            "turn_number": turn_number,
            "context": context_str,
        }
    )

    # Log errors and create SRS cards
    for err in tutor_response.errors:
        err_record = db.log_error(
            user_id=user_id,
            error_type=err.type.value,
            user_sentence=err.user_sentence,
            corrected_sentence=err.corrected_sentence,
            explanation=err.explanation,
            session_id=session_id,
            source_type="scenario",
        )
        db.create_card_from_error(error_id=err_record["error_id"])

    return {
        "tutor_message": tutor_response.message,
        "errors": [
            {
                "type": err.type.value,
                "user_sentence": err.user_sentence,
                "corrected_sentence": err.corrected_sentence,
                "explanation": err.explanation,
            }
            for err in tutor_response.errors
        ],
        "micro_task": tutor_response.micro_task,
        "session_id": str(session_id),
        "turn_number": turn_number + 1,
        "scenario_complete": tutor_response.scenario_complete or False,
        "success_evaluation": tutor_response.success_evaluation,
    }


# ============================================================================
# Drills Endpoints
# ============================================================================

@app.get("/api/drills/monologue", tags=["Drills"])
async def get_monologue_prompts(
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get all monologue prompts.

    Returns a list of all monologue speaking prompts with time limits.
    """
    from app.drills import MONOLOGUE_PROMPTS

    prompts_list = [
        {
            "prompt_id": prompt.prompt_id,
            "text": prompt.text,
            "level": prompt.level,
            "category": prompt.category,
            "time_limit_seconds": prompt.time_limit_seconds,
        }
        for prompt in MONOLOGUE_PROMPTS.values()
    ]

    return {"prompts": prompts_list, "count": len(prompts_list)}


@app.post("/api/drills/monologue/submit", tags=["Drills"])
async def submit_monologue(
    payload: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit a monologue (voice recording transcribed to text).

    Payload:
    {
        "prompt_id": "daily_routine",
        "transcript": "I wake up at 7 AM every day...",
        "duration_seconds": 120
    }

    Returns tutor feedback on the monologue.
    """
    from app.drills import MONOLOGUE_PROMPTS
    from app.tutor_agent import TutorAgent

    prompt_id = payload.get("prompt_id")
    transcript = payload.get("transcript")
    duration_seconds = payload.get("duration_seconds", 0)

    if not prompt_id or prompt_id not in MONOLOGUE_PROMPTS:
        raise HTTPException(status_code=400, detail="Invalid or missing prompt_id")

    if not isinstance(transcript, str) or not transcript.strip():
        raise HTTPException(status_code=400, detail="Invalid or missing transcript")

    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    prompt = MONOLOGUE_PROMPTS[prompt_id]

    # Create DB session
    session = db.create_session(
        user_id=user_id,
        session_type="monologue_drill",
        metadata={"prompt_id": prompt_id, "duration_seconds": duration_seconds}
    )
    session_id = session["session_id"]

    # Process through tutor
    tutor = TutorAgent()
    user = get_or_create_user(str(user_id))
    user_level = user.get('level', 'A1')

    context_str = f"Monologue drill: {prompt.text}"

    tutor_response = tutor.process_user_input(
        transcript,
        context={
            "mode": "monologue",
            "level": user_level,
            "prompt_id": prompt_id,
            "context": context_str,
        }
    )

    # Log errors and create SRS cards
    for err in tutor_response.errors:
        err_record = db.log_error(
            user_id=user_id,
            error_type=err.type.value,
            user_sentence=err.user_sentence,
            corrected_sentence=err.corrected_sentence,
            explanation=err.explanation,
            session_id=session_id,
            source_type="monologue",
        )
        db.create_card_from_error(error_id=err_record["error_id"])

    word_count = len(transcript.split())

    return {
        "message": tutor_response.message,
        "errors": [
            {
                "type": err.type.value,
                "user_sentence": err.user_sentence,
                "corrected_sentence": err.corrected_sentence,
                "explanation": err.explanation,
            }
            for err in tutor_response.errors
        ],
        "micro_task": tutor_response.micro_task,
        "session_id": str(session_id),
        "word_count": word_count,
        "duration_seconds": duration_seconds,
    }


@app.get("/api/drills/journal", tags=["Drills"])
async def get_journal_prompts(
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get all journal writing prompts.

    Returns a list of all journal prompts with minimum word counts.
    """
    from app.drills import JOURNAL_PROMPTS

    prompts_list = [
        {
            "prompt_id": prompt.prompt_id,
            "text": prompt.text,
            "level": prompt.level,
            "category": prompt.category,
            "min_words": prompt.min_words,
        }
        for prompt in JOURNAL_PROMPTS.values()
    ]

    return {"prompts": prompts_list, "count": len(prompts_list)}


@app.post("/api/drills/journal/submit", tags=["Drills"])
async def submit_journal(
    payload: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit a journal entry.

    Payload:
    {
        "prompt_id": "today_feeling",
        "content": "Today I am feeling happy because..."
    }

    Returns tutor feedback on the journal entry.
    """
    from app.drills import JOURNAL_PROMPTS
    from app.tutor_agent import TutorAgent

    prompt_id = payload.get("prompt_id")
    content = payload.get("content")

    if not prompt_id or prompt_id not in JOURNAL_PROMPTS:
        raise HTTPException(status_code=400, detail="Invalid or missing prompt_id")

    if not isinstance(content, str) or not content.strip():
        raise HTTPException(status_code=400, detail="Invalid or missing content")

    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    prompt = JOURNAL_PROMPTS[prompt_id]

    # Create DB session
    session = db.create_session(
        user_id=user_id,
        session_type="journal_drill",
        metadata={"prompt_id": prompt_id}
    )
    session_id = session["session_id"]

    # Process through tutor
    tutor = TutorAgent()
    user = get_or_create_user(str(user_id))
    user_level = user.get('level', 'A1')

    context_str = f"Journal prompt: {prompt.text}"

    tutor_response = tutor.process_user_input(
        content,
        context={
            "mode": "journal",
            "level": user_level,
            "prompt_id": prompt_id,
            "context": context_str,
        }
    )

    # Log errors and create SRS cards
    for err in tutor_response.errors:
        err_record = db.log_error(
            user_id=user_id,
            error_type=err.type.value,
            user_sentence=err.user_sentence,
            corrected_sentence=err.corrected_sentence,
            explanation=err.explanation,
            session_id=session_id,
            source_type="journal",
        )
        db.create_card_from_error(error_id=err_record["error_id"])

    word_count = len(content.split())

    return {
        "message": tutor_response.message,
        "errors": [
            {
                "type": err.type.value,
                "user_sentence": err.user_sentence,
                "corrected_sentence": err.corrected_sentence,
                "explanation": err.explanation,
            }
            for err in tutor_response.errors
        ],
        "micro_task": tutor_response.micro_task,
        "session_id": str(session_id),
        "word_count": word_count,
        "min_words": prompt.min_words,
    }


# ============================================================================
# Placement Test Endpoints
# ============================================================================

@app.get("/api/placement-test/questions", tags=["Placement Test"])
async def get_placement_test_questions():
    """
    Get placement test questions.

    Returns 12 questions covering A1-C2 levels.
    """
    from app.placement_test import placement_evaluator

    questions = placement_evaluator.get_questions(12)

    return {
        "questions": [
            {
                "question_id": q.question_id,
                "question_text": q.question_text,
                "options": q.options,
                "level": q.level,
                "skill_type": q.skill_type,
            }
            for q in questions
        ],
        "total_questions": len(questions),
    }


@app.post("/api/placement-test/submit", tags=["Placement Test"])
async def submit_placement_test(
    payload: dict,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit placement test answers and get results.

    Payload:
    {
        "answers": [0, 2, 1, 3, 0, ...]  // List of selected option indices
    }

    Returns level determination and feedback.
    """
    from app.placement_test import placement_evaluator

    answers = payload.get("answers", [])

    if not answers or not isinstance(answers, list):
        raise HTTPException(status_code=400, detail="Invalid answers format")

    # Evaluate the test
    result = placement_evaluator.evaluate_test(answers)

    # Update user's level in database
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    # Update user profile with determined level
    db.update_user_profile(
        user_id=user_id,
        level=result.level
    )

    return {
        "level": result.level,
        "score": result.score,
        "total_questions": len(answers),
        "strengths": result.strengths,
        "weaknesses": result.weaknesses,
        "recommendation": result.recommendation,
    }


# ============================================================================
# Exercise Endpoints
# ============================================================================

@app.get("/api/exercises/session", tags=["Exercises"])
async def get_exercise_session(
    count: int = 5,
    level: Optional[str] = None,
    skill: Optional[str] = None,
    exercise_type: Optional[str] = None,
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get a practice session with exercises.

    Args:
        count: Number of exercises (default 5)
        level: Filter by level (A1, A2, B1, B2, C1, C2)
        skill: Filter by skill type (grammar, vocabulary)
        exercise_type: Filter by type (multiple_choice, fill_blank, sentence_correction)

    Returns:
        List of exercises for the session
    """
    from app.exercises import exercise_manager, SkillType, ExerciseType

    # Convert string params to enums
    skill_enum = None
    if skill:
        try:
            skill_enum = SkillType(skill.lower())
        except ValueError:
            pass

    type_enum = None
    if exercise_type:
        try:
            type_enum = ExerciseType(exercise_type.lower())
        except ValueError:
            pass

    # Get user level if not specified
    if not level:
        try:
            user_id = uuid.UUID(user_id_from_token)
            user = get_or_create_user(str(user_id))
            level = user.get('level', 'B1')
        except:
            level = 'B1'

    exercises = exercise_manager.get_practice_session(
        count=count,
        level=level,
        skill=skill_enum,
        exercise_type=type_enum,
    )

    return {
        "exercises": [
            {
                "id": ex.exercise_id,
                "type": ex.exercise_type.value,
                "level": ex.level,
                "skill": ex.skill.value,
                "question": ex.question,
                "options": ex.options,
                "hint": ex.hint,
                # Don't send correct answer to client
            }
            for ex in exercises
        ],
        "count": len(exercises),
    }


@app.post("/api/exercises/submit", tags=["Exercises"])
async def submit_exercise_answer(
    payload: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Submit an answer for an exercise.

    Payload:
    {
        "exercise_id": "mc-gram-b1-001",
        "user_answer": "were"
    }

    Returns:
        is_correct, correct_answer, explanation, xp_earned
    """
    from app.exercises import exercise_manager

    exercise_id = payload.get("exercise_id")
    user_answer = payload.get("user_answer")

    if not exercise_id:
        raise HTTPException(status_code=400, detail="Missing exercise_id")
    if not user_answer and user_answer != 0:  # Allow 0 as answer
        raise HTTPException(status_code=400, detail="Missing user_answer")

    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        result = exercise_manager.check_answer(exercise_id, str(user_answer))
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

    # Calculate XP
    xp_earned = 10 if result["is_correct"] else 0

    # Log the exercise attempt
    try:
        session = db.create_session(
            user_id=user_id,
            session_type="exercise",
            metadata={
                "exercise_id": exercise_id,
                "user_answer": str(user_answer),
                "is_correct": result["is_correct"],
            }
        )

        # If incorrect, log as error for SRS
        if not result["is_correct"]:
            exercise = exercise_manager.get_exercise(exercise_id)
            if exercise:
                err_record = db.log_error(
                    user_id=user_id,
                    error_type=exercise.skill.value,
                    user_sentence=str(user_answer),
                    corrected_sentence=result["correct_answer"],
                    explanation=result["explanation"],
                    session_id=session["session_id"],
                    source_type="exercise",
                )
                db.create_card_from_error(error_id=err_record["error_id"])
    except Exception as e:
        # Log but don't fail the request
        print(f"Warning: Failed to log exercise: {e}")

    return {
        "is_correct": result["is_correct"],
        "correct_answer": result["correct_answer"],
        "explanation": result["explanation"],
        "xp_earned": xp_earned,
    }


@app.get("/api/exercises/{exercise_id}", tags=["Exercises"])
async def get_exercise(
    exercise_id: str,
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get a specific exercise by ID.

    Returns the exercise without the correct answer.
    """
    from app.exercises import exercise_manager

    exercise = exercise_manager.get_exercise(exercise_id)

    if not exercise:
        raise HTTPException(status_code=404, detail=f"Exercise '{exercise_id}' not found")

    return {
        "id": exercise.exercise_id,
        "type": exercise.exercise_type.value,
        "level": exercise.level,
        "skill": exercise.skill.value,
        "question": exercise.question,
        "options": exercise.options,
        "hint": exercise.hint,
    }


# ============================================================================
# Streaks Endpoints
# ============================================================================

@app.get("/api/streaks/current", tags=["Streaks"])
async def get_current_streak(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get current user's streak information.

    Requires JWT authentication. User ID is extracted from the token.

    Returns:
    - current_streak: Current consecutive days streak
    - longest_streak: Longest streak ever achieved
    - last_active_date: Date of last activity
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        streak_data = db.get_user_streak(user_id)

        if streak_data is None:
            return {
                "current_streak": 0,
                "longest_streak": 0,
                "last_active_date": None
            }

        return streak_data

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get streak data: {str(e)}"
        )


@app.post("/api/streaks/record-activity", tags=["Streaks"])
async def record_activity(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Record user activity and update streak.

    Call this when the user completes an exercise, lesson, or any meaningful activity.
    The streak logic handles:
    - First activity: creates streak record with 1 day
    - Already logged today: returns current streak (no change)
    - Continuing from yesterday: increments streak
    - Streak broken (gap > 1 day): resets to 1

    Returns:
    - current_streak: Current consecutive days streak
    - longest_streak: Longest streak ever achieved
    - last_active_date: Date of last activity
    - total_days_active: Total number of active days
    - freeze_days_available: Freeze days remaining
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        streak_data = db.record_activity(user_id)
        return streak_data

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to record activity: {str(e)}"
        )


# ============================================================================
# Daily Goals Endpoints
# ============================================================================

@app.get("/api/goals/today", tags=["Goals"])
async def get_today_goal(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get today's daily goal for the authenticated user.

    Creates a goal with default targets if it doesn't exist.

    Returns:
    - goal_id: Goal UUID
    - user_id: User UUID
    - goal_date: Date of the goal
    - target_study_minutes: Target study time in minutes
    - target_lessons: Target number of lessons
    - target_reviews: Target number of reviews
    - target_drills: Target number of drills
    - actual_study_minutes: Actual study time completed
    - actual_lessons: Actual lessons completed
    - actual_reviews: Actual reviews completed
    - actual_drills: Actual drills completed
    - completed: Whether all goals are completed
    - completion_percentage: Overall completion percentage (0-100)
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        # Try to get existing goal
        goal = db.get_daily_goal(user_id)

        # If no goal exists, create one with default targets
        if not goal:
            goal = db.create_or_update_daily_goal(
                user_id=user_id,
                target_study_minutes=30,
                target_lessons=1,
                target_reviews=10,
                target_drills=2
            )

        return goal

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get daily goal: {str(e)}"
        )


@app.post("/api/goals/today", tags=["Goals"])
async def update_today_goal(
    targets: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Update today's goal targets for the authenticated user.

    Request body:
    {
        "target_study_minutes": 45,
        "target_lessons": 2,
        "target_reviews": 15,
        "target_drills": 3
    }

    All fields are optional - only provided fields will be updated.

    Returns the updated daily goal.
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        # Extract targets from request
        target_study_minutes = targets.get("target_study_minutes")
        target_lessons = targets.get("target_lessons")
        target_reviews = targets.get("target_reviews")
        target_drills = targets.get("target_drills")

        # Update or create goal with new targets
        goal = db.create_or_update_daily_goal(
            user_id=user_id,
            target_study_minutes=target_study_minutes,
            target_lessons=target_lessons,
            target_reviews=target_reviews,
            target_drills=target_drills
        )

        return goal

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to update daily goal: {str(e)}"
        )


@app.post("/api/goals/today/progress", tags=["Goals"])
async def update_goal_progress(
    progress: dict = Body(...),
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Increment today's goal progress for the authenticated user.

    Request body:
    {
        "study_minutes": 15,
        "lessons": 1,
        "reviews": 5,
        "drills": 1
    }

    All fields are optional and default to 0.
    This endpoint increments the current progress values.

    Returns the updated daily goal with new progress.
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        # Extract progress increments from request
        study_minutes = progress.get("study_minutes", 0)
        lessons = progress.get("lessons", 0)
        reviews = progress.get("reviews", 0)
        drills = progress.get("drills", 0)

        # Increment progress
        goal = db.increment_daily_goal_progress(
            user_id=user_id,
            study_minutes=study_minutes,
            lessons=lessons,
            reviews=reviews,
            drills=drills
        )

        return goal

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to update goal progress: {str(e)}"
        )


# ============================================================================
# Leaderboard Endpoints
# ============================================================================

@app.get("/api/leaderboard/weekly", tags=["Leaderboard"])
async def get_weekly_leaderboard(
    limit: int = 50,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get weekly leaderboard (top users by XP gained this week).

    Returns top 50 users plus authenticated user's rank if not in top 50.
    XP is calculated based on completed sessions (10 XP per session).

    Returns:
        - leaderboard: Array of top users with rank, name, xp, level
        - current_user: Current user's rank and stats (if authenticated)
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        result = db.get_weekly_leaderboard(limit=limit, current_user_id=user_id)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get weekly leaderboard: {str(e)}"
        )


@app.get("/api/leaderboard/monthly", tags=["Leaderboard"])
async def get_monthly_leaderboard(
    limit: int = 50,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get monthly leaderboard (top users by XP gained this month).

    Returns top 50 users plus authenticated user's rank if not in top 50.
    XP is calculated based on completed sessions (10 XP per session).

    Returns:
        - leaderboard: Array of top users with rank, name, xp, level
        - current_user: Current user's rank and stats (if authenticated)
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        result = db.get_monthly_leaderboard(limit=limit, current_user_id=user_id)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get monthly leaderboard: {str(e)}"
        )


@app.get("/api/leaderboard/alltime", tags=["Leaderboard"])
async def get_alltime_leaderboard(
    limit: int = 50,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get all-time leaderboard (top users by total XP).

    Returns top 50 users plus authenticated user's rank if not in top 50.
    XP is calculated based on all completed sessions (10 XP per session).

    Returns:
        - leaderboard: Array of top users with rank, name, total_xp, level
        - current_user: Current user's rank and stats (if authenticated)
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        result = db.get_alltime_leaderboard(limit=limit, current_user_id=user_id)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get all-time leaderboard: {str(e)}"
        )


@app.get("/api/leaderboard/streaks", tags=["Leaderboard"])
async def get_streak_leaderboard(
    limit: int = 50,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get streak leaderboard (top users by current streak days).

    Returns top 50 users plus authenticated user's rank if not in top 50.

    Returns:
        - leaderboard: Array of top users with rank, name, current_streak, level
        - current_user: Current user's rank and stats (if authenticated)
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        result = db.get_streak_leaderboard(limit=limit, current_user_id=user_id)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get streak leaderboard: {str(e)}"
        )


# ============================================================================
# Notifications Endpoints
# ============================================================================

@app.get("/api/notifications", tags=["Notifications"])
async def get_notifications(
    limit: int = 20,
    offset: int = 0,
    unread_only: bool = False,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get user's notifications (paginated, unread first).

    Query params:
    - limit: Maximum number of notifications to return (default 20)
    - offset: Number of notifications to skip (default 0)
    - unread_only: If true, only return unread notifications (default false)

    Returns:
    - notifications: List of notification objects
    - count: Total number of notifications returned
    - has_more: Whether there are more notifications to load
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        notifications = db.get_notifications(
            user_id=user_id,
            limit=limit + 1,  # Get one extra to check if there are more
            offset=offset,
            unread_only=unread_only
        )

        has_more = len(notifications) > limit
        if has_more:
            notifications = notifications[:limit]

        # Convert datetime objects to ISO strings for JSON serialization
        for notif in notifications:
            if notif.get('created_at'):
                notif['created_at'] = notif['created_at'].isoformat()
            if notif.get('read_at'):
                notif['read_at'] = notif['read_at'].isoformat()

        return {
            "notifications": notifications,
            "count": len(notifications),
            "has_more": has_more
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get notifications: {str(e)}"
        )


@app.post("/api/notifications/{notification_id}/read", tags=["Notifications"])
async def mark_notification_read(
    notification_id: uuid.UUID,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Mark a notification as read.

    Args:
        notification_id: UUID of the notification to mark as read

    Returns:
        Success confirmation
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        # Verify the notification belongs to this user
        notifications = db.get_notifications(user_id=user_id, limit=1000)
        notification_ids = [n['notification_id'] for n in notifications]

        if notification_id not in notification_ids:
            raise HTTPException(status_code=404, detail="Notification not found")

        success = db.mark_notification_read(notification_id)

        if not success:
            raise HTTPException(status_code=404, detail="Notification not found or already read")

        return {
            "status": "success",
            "message": "Notification marked as read",
            "notification_id": str(notification_id)
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to mark notification as read: {str(e)}"
        )


@app.post("/api/notifications/read-all", tags=["Notifications"])
async def mark_all_notifications_read(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Mark all notifications as read for the authenticated user.

    Returns:
        Number of notifications marked as read
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        count = db.mark_all_notifications_read(user_id)

        return {
            "status": "success",
            "message": f"Marked {count} notification(s) as read",
            "count": count
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to mark all notifications as read: {str(e)}"
        )


@app.get("/api/notifications/unread-count", tags=["Notifications"])
async def get_unread_notification_count(
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get unread notification count for badge display.

    Returns:
        Unread notification count
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        count = db.get_unread_notification_count(user_id)

        return {
            "unread_count": count
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get unread count: {str(e)}"
        )


# ============================================================================
# Conversation History Endpoints
# ============================================================================

@app.get("/api/tutor/history", tags=["Tutor"])
async def get_conversation_history(
    limit: int = 20,
    context_type: Optional[str] = None,
    context_id: Optional[str] = None,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get conversation history for the authenticated user.

    Query params:
    - limit: Maximum number of conversation turns to return (default 20)
    - context_type: Filter by context type (scenario, lesson, free_chat, etc.)
    - context_id: Filter by specific context ID (scenario_id, lesson_id, etc.)

    Returns:
    - conversations: List of conversation turns with user messages and tutor responses
    - count: Total number of conversations returned
    - summary: High-level summary of conversation patterns
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        # Get filtered conversations if context specified
        if context_type:
            conversations = db.get_conversation_by_context(
                user_id=user_id,
                context_type=context_type,
                context_id=context_id,
                limit=limit
            )
        else:
            # Get recent conversations
            conversations = db.get_recent_conversations(user_id, limit=limit)

        # Get conversation summary
        summary = db.get_conversation_context(user_id, lookback_days=30)

        # Convert datetime objects to ISO strings
        for conv in conversations:
            if conv.get('created_at'):
                conv['created_at'] = conv['created_at'].isoformat()

        return {
            "conversations": conversations,
            "count": len(conversations),
            "summary": summary
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get conversation history: {str(e)}"
        )


@app.delete("/api/tutor/history", tags=["Tutor"])
async def clear_conversation_history(
    before_date: Optional[str] = None,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Clear conversation history for the authenticated user.

    Query params:
    - before_date: Optional ISO date string - only clear conversations before this date

    Returns:
    - deleted_count: Number of conversation turns deleted
    - message: Success message
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        # Parse before_date if provided
        before_datetime = None
        if before_date:
            try:
                from datetime import datetime as dt
                before_datetime = dt.fromisoformat(before_date.replace('Z', '+00:00'))
            except Exception:
                raise HTTPException(status_code=400, detail="Invalid date format. Use ISO 8601 format.")

        # Clear conversation history
        deleted_count = db.clear_conversation_history(
            user_id=user_id,
            before_date=before_datetime
        )

        return {
            "status": "success",
            "message": f"Cleared {deleted_count} conversation turn(s)",
            "deleted_count": deleted_count
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to clear conversation history: {str(e)}"
        )


@app.get("/api/tutor/memory-summary", tags=["Tutor"])
async def get_memory_summary(
    lookback_days: int = 30,
    db: Database = Depends(get_database),
    user_id_from_token: str = Depends(verify_token),
):
    """
    Get a summary of the tutor's memory about the user.

    Shows what the tutor "remembers" about past conversations,
    including topics discussed, contexts used, and conversation patterns.

    Query params:
    - lookback_days: Number of days to look back (default 30)

    Returns:
    - total_conversations: Total number of conversation turns
    - recent_topics: List of recent conversation contexts
    - most_active_context: The most frequently used context type
    - last_conversation_date: Date of last conversation
    """
    try:
        user_id = uuid.UUID(user_id_from_token)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid user_id from token")

    try:
        summary = db.get_conversation_context(
            user_id=user_id,
            lookback_days=lookback_days
        )

        if not summary:
            return {
                "total_conversations": 0,
                "recent_topics": [],
                "most_active_context": None,
                "last_conversation_date": None
            }

        # Extract data from summary
        context_summary = summary.get('context_summary', {})

        return {
            "total_conversations": summary.get('total_conversations', 0),
            "recent_topics": summary.get('recent_topics', []),
            "most_active_context": context_summary.get('most_active_context'),
            "last_conversation_date": context_summary.get('last_conversation_date')
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to get memory summary: {str(e)}"
        )


if __name__ == "__main__":
    import uvicorn

    print("Starting SpeakSharp API server...")
    print("Docs available at: http://localhost:8000/docs")

    uvicorn.run(
        "app.api:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
